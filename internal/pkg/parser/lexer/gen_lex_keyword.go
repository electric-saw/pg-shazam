// Code generated by go generate; DO NOT EDIT.

package lexer

import "strings"

//gocyclo:ignore
const (
	keywordAlter     = "alter"
	keywordAnd       = "and"
	keywordAs        = "as"
	keywordBegin     = "begin"
	keywordBool      = "bool"
	keywordBy        = "by"
	keywordCascade   = "cascade"
	keywordCommit    = "commit"
	keywordCreate    = "create"
	keywordCross     = "cross"
	keywordDate      = "date"
	keywordDatetime  = "datetime"
	keywordDay       = "day"
	keywordDelete    = "delete"
	keywordDrop      = "drop"
	keywordFloat     = "float"
	keywordFrom      = "from"
	keywordFull      = "full"
	keywordHash      = "hash"
	keywordHour      = "hour"
	keywordIn        = "in"
	keywordInner     = "inner"
	keywordInsert    = "insert"
	keywordInt       = "int"
	keywordInterval  = "interval"
	keywordInto      = "into"
	keywordIs        = "is"
	keywordJoin      = "join"
	keywordLeft      = "left"
	keywordLike      = "like"
	keywordMinute    = "minute"
	keywordMonth     = "month"
	keywordNot       = "not"
	keywordNull      = "null"
	keywordOn        = "on"
	keywordOr        = "or"
	keywordOuter     = "outer"
	keywordRight     = "right"
	keywordSecond    = "second"
	keywordSelect    = "select"
	keywordSet       = "set"
	keywordString    = "string"
	keywordTable     = "table"
	keywordText      = "text"
	keywordTime      = "time"
	keywordTimestamp = "timestamp"
	keywordTo        = "to"
	keywordUpdate    = "update"
	keywordUsing     = "using"
	keywordValues    = "values"
	keywordWhere     = "where"
	keywordYear      = "year"
)

func lexKeyword(source string, srcCursor cursor) (*Token, cursor, bool) {
	var cur cursor = srcCursor

	if len(source[cur.pointer:]) >= 4 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+4], "year") {
			cur.pointer += 4
			cur.loc.Col += 4
			return &Token{Kind: KindKeyword, Value: string(keywordYear), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 6 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+6], "values") {
			cur.pointer += 6
			cur.loc.Col += 6
			return &Token{Kind: KindKeyword, Value: string(keywordValues), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 5 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+5], "where") {
			cur.pointer += 5
			cur.loc.Col += 5
			return &Token{Kind: KindKeyword, Value: string(keywordWhere), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 4 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+4], "join") {
			cur.pointer += 4
			cur.loc.Col += 4
			return &Token{Kind: KindKeyword, Value: string(keywordJoin), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 5 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+5], "right") {
			cur.pointer += 5
			cur.loc.Col += 5
			return &Token{Kind: KindKeyword, Value: string(keywordRight), Loc: srcCursor.loc}, cur, true
		}
	}

	switch source[cur.pointer] {
	case 'i', 'I':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'n', 'N':
				cur.pointer++
				cur.loc.Col++

				if len(source[cur.pointer:]) >= 1 /* sub group */ {
					switch source[cur.pointer] {
					case 't', 'T':
						cur.pointer++
						cur.loc.Col++

						if len(source[cur.pointer:]) >= 1 /* sub group */ {
							switch source[cur.pointer] {
							case 'o', 'O':
								cur.pointer++
								cur.loc.Col++
								return &Token{Kind: KindKeyword, Value: string(keywordInto), Loc: srcCursor.loc}, cur, true
							}

							if len(source[cur.pointer:]) >= 5 {
								if strings.EqualFold(source[cur.pointer:cur.pointer+5], "erval") {
									cur.pointer += 5
									cur.loc.Col += 5
									return &Token{Kind: KindKeyword, Value: string(keywordInterval), Loc: srcCursor.loc}, cur, true
								}
							}

						}

					}

					if len(source[cur.pointer:]) >= 3 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ner") {
							cur.pointer += 3
							cur.loc.Col += 3
							return &Token{Kind: KindKeyword, Value: string(keywordInner), Loc: srcCursor.loc}, cur, true
						}
					}

					if len(source[cur.pointer:]) >= 4 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+4], "sert") {
							cur.pointer += 4
							cur.loc.Col += 4
							return &Token{Kind: KindKeyword, Value: string(keywordInsert), Loc: srcCursor.loc}, cur, true
						}
					}

				}

			case 's', 'S':
				cur.pointer++
				cur.loc.Col++
				return &Token{Kind: KindKeyword, Value: string(keywordIs), Loc: srcCursor.loc}, cur, true
			}
		}

	case 't', 'T':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'o', 'O':
				cur.pointer++
				cur.loc.Col++
				return &Token{Kind: KindKeyword, Value: string(keywordTo), Loc: srcCursor.loc}, cur, true
			case 'i', 'I':
				cur.pointer++
				cur.loc.Col++

				if len(source[cur.pointer:]) >= 1 /* sub group */ {
					switch source[cur.pointer] {
					case 'm', 'M':
						cur.pointer++
						cur.loc.Col++

						if len(source[cur.pointer:]) >= 1 /* sub group */ {
							switch source[cur.pointer] {
							case 'e', 'E':
								cur.pointer++
								cur.loc.Col++

								if len(source[cur.pointer:]) >= 1 /* sub group */ {

									if len(source[cur.pointer:]) >= 5 {
										if strings.EqualFold(source[cur.pointer:cur.pointer+5], "stamp") {
											cur.pointer += 5
											cur.loc.Col += 5
											return &Token{Kind: KindKeyword, Value: string(keywordTimestamp), Loc: srcCursor.loc}, cur, true
										}
									}

								}

								return &Token{Kind: KindKeyword, Value: string(keywordTime), Loc: srcCursor.loc}, cur, true
							}
						}

					}
				}

			}

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ext") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordText), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "able") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordTable), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 's', 'S':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'e', 'E':
				cur.pointer++
				cur.loc.Col++

				if len(source[cur.pointer:]) >= 1 /* sub group */ {
					switch source[cur.pointer] {
					case 't', 'T':
						cur.pointer++
						cur.loc.Col++
						return &Token{Kind: KindKeyword, Value: string(keywordSet), Loc: srcCursor.loc}, cur, true
					}

					if len(source[cur.pointer:]) >= 4 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+4], "lect") {
							cur.pointer += 4
							cur.loc.Col += 4
							return &Token{Kind: KindKeyword, Value: string(keywordSelect), Loc: srcCursor.loc}, cur, true
						}
					}

					if len(source[cur.pointer:]) >= 4 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+4], "cond") {
							cur.pointer += 4
							cur.loc.Col += 4
							return &Token{Kind: KindKeyword, Value: string(keywordSecond), Loc: srcCursor.loc}, cur, true
						}
					}

				}

			}

			if len(source[cur.pointer:]) >= 5 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+5], "tring") {
					cur.pointer += 5
					cur.loc.Col += 5
					return &Token{Kind: KindKeyword, Value: string(keywordString), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'h', 'H':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "our") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordHour), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ash") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordHash), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'c', 'C':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'r', 'R':
				cur.pointer++
				cur.loc.Col++

				if len(source[cur.pointer:]) >= 1 /* sub group */ {

					if len(source[cur.pointer:]) >= 4 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+4], "eate") {
							cur.pointer += 4
							cur.loc.Col += 4
							return &Token{Kind: KindKeyword, Value: string(keywordCreate), Loc: srcCursor.loc}, cur, true
						}
					}

					if len(source[cur.pointer:]) >= 3 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+3], "oss") {
							cur.pointer += 3
							cur.loc.Col += 3
							return &Token{Kind: KindKeyword, Value: string(keywordCross), Loc: srcCursor.loc}, cur, true
						}
					}

				}

			}

			if len(source[cur.pointer:]) >= 6 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+6], "ascade") {
					cur.pointer += 6
					cur.loc.Col += 6
					return &Token{Kind: KindKeyword, Value: string(keywordCascade), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 5 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+5], "ommit") {
					cur.pointer += 5
					cur.loc.Col += 5
					return &Token{Kind: KindKeyword, Value: string(keywordCommit), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'b', 'B':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'y', 'Y':
				cur.pointer++
				cur.loc.Col++
				return &Token{Kind: KindKeyword, Value: string(keywordBy), Loc: srcCursor.loc}, cur, true
			}

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "egin") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordBegin), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ool") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordBool), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'o', 'O':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'n', 'N':
				cur.pointer++
				cur.loc.Col++
				return &Token{Kind: KindKeyword, Value: string(keywordOn), Loc: srcCursor.loc}, cur, true
			case 'r', 'R':
				cur.pointer++
				cur.loc.Col++
				return &Token{Kind: KindKeyword, Value: string(keywordOr), Loc: srcCursor.loc}, cur, true
			}

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "uter") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordOuter), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'd', 'D':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 'a', 'A':
				cur.pointer++
				cur.loc.Col++

				if len(source[cur.pointer:]) >= 1 /* sub group */ {
					switch source[cur.pointer] {
					case 'y', 'Y':
						cur.pointer++
						cur.loc.Col++
						return &Token{Kind: KindKeyword, Value: string(keywordDay), Loc: srcCursor.loc}, cur, true
					}

					if len(source[cur.pointer:]) >= 6 {
						if strings.EqualFold(source[cur.pointer:cur.pointer+6], "tetime") {
							cur.pointer += 6
							cur.loc.Col += 6
							return &Token{Kind: KindKeyword, Value: string(keywordDatetime), Loc: srcCursor.loc}, cur, true
						}
					}

				}

			}

			if len(source[cur.pointer:]) >= 5 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+5], "elete") {
					cur.pointer += 5
					cur.loc.Col += 5
					return &Token{Kind: KindKeyword, Value: string(keywordDelete), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "rop") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordDrop), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'u', 'U':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {

			if len(source[cur.pointer:]) >= 5 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+5], "pdate") {
					cur.pointer += 5
					cur.loc.Col += 5
					return &Token{Kind: KindKeyword, Value: string(keywordUpdate), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "sing") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordUsing), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'l', 'L':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "eft") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordLeft), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ike") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordLike), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'f', 'F':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ull") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordFull), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "rom") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordFrom), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "loat") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordFloat), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'n', 'N':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {

			if len(source[cur.pointer:]) >= 3 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+3], "ull") {
					cur.pointer += 3
					cur.loc.Col += 3
					return &Token{Kind: KindKeyword, Value: string(keywordNull), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 2 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+2], "ot") {
					cur.pointer += 2
					cur.loc.Col += 2
					return &Token{Kind: KindKeyword, Value: string(keywordNot), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'a', 'A':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {
			switch source[cur.pointer] {
			case 's', 'S':
				cur.pointer++
				cur.loc.Col++
				return &Token{Kind: KindKeyword, Value: string(keywordAs), Loc: srcCursor.loc}, cur, true
			}

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "lter") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordAlter), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 2 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+2], "nd") {
					cur.pointer += 2
					cur.loc.Col += 2
					return &Token{Kind: KindKeyword, Value: string(keywordAnd), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	case 'm', 'M':
		cur.pointer++
		cur.loc.Col++

		if len(source[cur.pointer:]) >= 1 /* sub group */ {

			if len(source[cur.pointer:]) >= 4 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+4], "onth") {
					cur.pointer += 4
					cur.loc.Col += 4
					return &Token{Kind: KindKeyword, Value: string(keywordMonth), Loc: srcCursor.loc}, cur, true
				}
			}

			if len(source[cur.pointer:]) >= 5 {
				if strings.EqualFold(source[cur.pointer:cur.pointer+5], "inute") {
					cur.pointer += 5
					cur.loc.Col += 5
					return &Token{Kind: KindKeyword, Value: string(keywordMinute), Loc: srcCursor.loc}, cur, true
				}
			}

		}

	}
	return nil, srcCursor, false
}

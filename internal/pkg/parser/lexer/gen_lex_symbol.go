// Code generated by go generate; DO NOT EDIT.

package lexer

import "strings"

//gocyclo:ignore
const (
	SymbolAmp       = "&"
	SymbolColon     = ":"
	SymbolComma     = ","
	SymbolConcat    = "||"
	SymbolDiv       = "/"
	SymbolDot       = "."
	SymbolEq        = "="
	SymbolGt        = ">"
	SymbolGte       = ">="
	SymbolLParen    = "("
	SymbolLt        = "<"
	SymbolLte       = "<="
	SymbolMinus     = "-"
	SymbolMod       = "%"
	SymbolMul       = "*"
	SymbolNeq       = "!="
	SymbolPlus      = "+"
	SymbolRParen    = ")"
	SymbolSemicolon = ";"
)

func lexSymbol(source string, srcCursor cursor) (*Token, cursor, bool) {
	var cur cursor = srcCursor

	if len(source[cur.pointer:]) >= 2 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+2], "<=") {
			cur.pointer += 2
			cur.loc.Col += 2
			return &Token{Kind: KindSymbol, Value: string(SymbolLte), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 2 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+2], ">=") {
			cur.pointer += 2
			cur.loc.Col += 2
			return &Token{Kind: KindSymbol, Value: string(SymbolGte), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 2 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+2], "!=") {
			cur.pointer += 2
			cur.loc.Col += 2
			return &Token{Kind: KindSymbol, Value: string(SymbolNeq), Loc: srcCursor.loc}, cur, true
		}
	}

	if len(source[cur.pointer:]) >= 2 {
		if strings.EqualFold(source[cur.pointer:cur.pointer+2], "||") {
			cur.pointer += 2
			cur.loc.Col += 2
			return &Token{Kind: KindSymbol, Value: string(SymbolConcat), Loc: srcCursor.loc}, cur, true
		}
	}

	switch source[cur.pointer] {
	case '*':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolMul), Loc: srcCursor.loc}, cur, true
	case '/':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolDiv), Loc: srcCursor.loc}, cur, true
	case '(':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolLParen), Loc: srcCursor.loc}, cur, true
	case '&':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolAmp), Loc: srcCursor.loc}, cur, true
	case ',':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolComma), Loc: srcCursor.loc}, cur, true
	case '+':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolPlus), Loc: srcCursor.loc}, cur, true
	case '%':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolMod), Loc: srcCursor.loc}, cur, true
	case '.':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolDot), Loc: srcCursor.loc}, cur, true
	case '-':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolMinus), Loc: srcCursor.loc}, cur, true
	case ')':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolRParen), Loc: srcCursor.loc}, cur, true
	case ':':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolColon), Loc: srcCursor.loc}, cur, true
	case ';':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolSemicolon), Loc: srcCursor.loc}, cur, true
	case '=':
		cur.pointer++
		cur.loc.Col++
		return &Token{Kind: KindSymbol, Value: string(SymbolEq), Loc: srcCursor.loc}, cur, true
	}
	return nil, srcCursor, false
}
